import matplotlib.pyplot as plt
import random, itertools
import numpy as np
import math

from random import randint

from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram

# Brute force period finding algorithm
def find_period_classical(x, N):
    n = 1
    t = x
    while t != 1:
        t *= x
        t %= N
        n += 1
    return n

# Sieve of Eratosthenes algorithm
def sieve():
    D = {}
    yield 2
    for q in itertools.islice(itertools.count(3), 0, None, 2):
        p = D.pop(q, None)
        if p is None:
            D[q*q] = q
            yield q
        else:
            x = p + q
            while x in D or not (x&1):
                x += p
            D[x] = p

# Creates a list of prime numbers up to the given argument
def get_primes_sieve(n):
    L = list(itertools.takewhile(lambda p: p<n, sieve()))
    return L

# Get a simiprime number of N
def get_semiprime(n):
    primes = get_primes_sieve(n)
    print("[DEBUG] primes: {}".format(primes))

    l = len(primes)
    p = primes[random.randrange(l)]
    print("[DEBUG] primes: p={}".format(p))

    q = primes[random.randrange(l)]
    print("[DEBUG] primes: q={}".format(q))

    print("[DEBUG] p*q: {}".format(p*q))

    return p*q

# Perform Shor's algorithm in classical steps
def shors_algorithm_classical(x, N):
    # step 1: randomize a number
    # x = random.randint(0, N)
    print("  + Step 1: selected-randomized x = {}".format(x))

    # step 2: find the greatest common divisor
    if(math.gcd(x, N) != 1):
        return x, 0, math.gcd(x, N), N/math.gcd(x, N)
    print("  + Step 2: find thre greatest common divisor")
    
    # step 3: find period of x mod N
    r = find_period_classical(x, N)
    print("  + Step 3: find the period of x mod N ({})".format(r))

    # step 4: ignoring the case where (x^(r/2) +/- 1) is a multiple of N
    print("  + Step 4: ignoring the case - a multiple of N")
    while(r % 2 != 0):
        r = find_period_classical(x, N)

    p = math.gcd(x**int(r/2)+1,N)
    q = math.gcd(x**int(r/2)-1,N)

    return x,r,p,q

N = 21
x = 2
list_primes = get_primes_sieve(N)
print("List of primes of N={}: {}".format(N, list_primes))
print("-------------------------------------------------")

# get the semiprime generated by the numbers < N
simiprime = get_semiprime(N)
print("Semiprime of N={}: {}".format(N, simiprime))
print("-------------------------------------------------")

# the steps of Shor's algorithm to do factorization
x,r,p,q = shors_algorithm_classical(x, N)

print("-------------------------------------------------")
print("Shor result for N={} (semiprime):".format(N))
print("  + coprime: x={}".format(x))
print("  + period:  r={}".format(r))
print("  + prime factors: p={}".format(p))
print("  + prime factors: q={}".format(q))
print("-------------------------------------------------")
print("")

# In mathematics, a semiprime is a natural number that is the product of exactly two prime numbers.
# The two primes in the product may equal each other, so the semiprimes include the squares of prime numbers.
#
# Co-prime numbers or relatively prime numbers are those numbers that have their HCF (Highest Common Factor) as 1.

# qc = quantum circuit, qr = quantum register, cr = classical register, a = 2, 7, 8, 11 or 13
def circuit_amod15(qc,qr,cr,a):
    if a == 2:
        qc.cswap(qr[4],qr[3],qr[2])
        qc.cswap(qr[4],qr[2],qr[1])
        qc.cswap(qr[4],qr[1],qr[0])
    elif a == 7:
        qc.cswap(qr[4],qr[1],qr[0])
        qc.cswap(qr[4],qr[2],qr[1])
        qc.cswap(qr[4],qr[3],qr[2])
        qc.cx(qr[4],qr[3])
        qc.cx(qr[4],qr[2])
        qc.cx(qr[4],qr[1])
        qc.cx(qr[4],qr[0])
    elif a == 8:
        qc.cswap(qr[4],qr[1],qr[0])
        qc.cswap(qr[4],qr[2],qr[1])
        qc.cswap(qr[4],qr[3],qr[2])
    elif a == 11: # this is included for completeness
        qc.cswap(qr[4],qr[2],qr[0])
        qc.cswap(qr[4],qr[3],qr[1])
        qc.cx(qr[4],qr[3])
        qc.cx(qr[4],qr[2])
        qc.cx(qr[4],qr[1])
        qc.cx(qr[4],qr[0])
    elif a == 13:
        qc.cswap(qr[4],qr[3],qr[2])
        qc.cswap(qr[4],qr[2],qr[1])
        qc.cswap(qr[4],qr[1],qr[0])
        qc.cx(qr[4],qr[3])
        qc.cx(qr[4],qr[2])
        qc.cx(qr[4],qr[1])
        qc.cx(qr[4],qr[0])

# qc = quantum circuit, qr = quantum register, cr = classical register, a = 2, 7, 8, 11 or 13
def circuit_aperiod15(qc,qr,cr,a):
    if a == 11:
        circuit_11period15(qc,qr,cr)
        return
    
    # Initialize q[0] to |1> 
    qc.x(qr[0])

    # Apply a**4 mod 15
    qc.h(qr[4])
    #   controlled identity on the remaining 4 qubits, which is equivalent to doing nothing
    qc.h(qr[4])
    #   measure
    qc.measure(qr[4],cr[0])
    #   reinitialise q[4] to |0>
    qc.reset(qr[4])

    # Apply a**2 mod 15
    qc.h(qr[4])
    #   controlled unitary
    qc.cx(qr[4],qr[2])
    qc.cx(qr[4],qr[0])
    #   feed forward
    qc.p(math.pi/2.,qr[4]).c_if(cr, 1)
    qc.h(qr[4])
    #   measure
    qc.measure(qr[4],cr[1])
    #   reinitialise q[4] to |0>
    qc.reset(qr[4])

    # Apply a mod 15
    qc.h(qr[4])
    #   controlled unitary.
    circuit_amod15(qc,qr,cr,a)
    #   feed forward
    qc.p(3.*math.pi/4.,qr[4]).c_if(cr, 3)
    qc.p(math.pi/2.,qr[4]).c_if(cr, 2)
    qc.p(math.pi/4.,qr[4]).c_if(cr, 1)
    qc.h(qr[4])
    #   measure
    qc.measure(qr[4], cr[2])

def circuit_11period15(qc,qr,cr):
    # Initialize q[0] to |1> 
    qc.x(qr[0])

    # Apply a**4 mod 15
    qc.h(qr[4])
    #   controlled identity on the remaining 4 qubits, which is equivalent to doing nothing
    qc.h(qr[4])
    #   measure
    qc.measure(qr[4],cr[0])
    #   reinitialise q[4] to |0>
    qc.reset(qr[4])

    # Apply a**2 mod 15
    qc.h(qr[4])
    #   controlled identity on the remaining 4 qubits, which is equivalent to doing nothing
    #   feed forward
    qc.p(math.pi/2.,qr[4]).c_if(cr, 1)
    qc.h(qr[4])
    #   measure
    qc.measure(qr[4],cr[1])
    #   reinitialise q[4] to |0>
    qc.reset(qr[4])

    # Apply 11 mod 15
    qc.h(qr[4])
    #   controlled unitary.
    qc.cx(qr[4],qr[3])
    qc.cx(qr[4],qr[1])
    #   feed forward
    qc.p(3.*math.pi/4.,qr[4]).c_if(cr, 3)
    qc.p(math.pi/2.,qr[4]).c_if(cr, 2)
    qc.p(math.pi/4.,qr[4]).c_if(cr, 1)
    qc.h(qr[4])
    #   measure
    qc.measure(qr[4],cr[2])

q = QuantumRegister(5, 'q')
c = ClassicalRegister(5, 'c')

shor = QuantumCircuit(q, c)
circuit_aperiod15(shor, q, c, 7)
# shor.draw(output='mpl')
# plt.show()

simulator = AerSimulator()
circ = transpile(shor, simulator)

# Run and get counts
result = simulator.run(circ).result()
counts = result.get_counts(circ)
plot_histogram(counts, title='Shor Factorizing N=15')
plt.show()
